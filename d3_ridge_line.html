<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Vertical Bar Chart</title>
    <script src="https://d3js.org/d3.v7.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
  </head>
  
  <body>
    <div id="select_state">
      <select id="states"></select>
    </div>
  	<div id="state_hist"></div>
  </body>
  <script>
    // This is what I need to compute kernel density estimation
    function kde(kernel, thresholds, data) {
      return thresholds.map(t => [t, d3.mean(data, d => kernel(t - d))]);
    }
    
    function epanechnikov(bandwidth) {
      return x => Math.abs(x /= bandwidth) <= 1 ? 0.75 * (1 - x * x) / bandwidth : 0;
    }
    var brewery_data = "https://raw.githubusercontent.com/kkcp-dsi/CraftBeerRatingsAnalysis/main/data/all_breweries.csv"
    var rowConverter = function (d) {
      return {
        state: d.state,
        average_rating: +d.average_rating,
        num_of_beers: +d.num_of_beers
        }
    };
    // set the dimensions and margins of the graph
    var margin = {top: 100, right: 30, bottom: 20, left:110},
        width = 800 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;
        hist_height = 300
    // append the svg object to the body of the page
    var svg = d3.select("#state_hist")
      .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
      .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
    
    d3.csv(brewery_data, rowConverter).then(function(data){
        //Process the data
        var state_average_beers = {};
        for (var i = 0; i < data.length; i++) {
          if (!(data[i].state in state_average_beers))
          {
            state_average_beers[data[i].state] = [];
          }
          state_average_beers[data[i].state].push(data[i].average_rating); 
        }
        
        var allStates = Object.keys(state_average_beers);
        
        //var allStates = ["California", "New York", "Iowa", "New Jersey"];
        
         // X axis: scale and draw:
        var x = d3.scaleLinear()
          .domain([2.0, 5.0]) 
          .range([0, width]);
    
        var y = d3.scaleLinear()
          .domain([0.0, 6.0])
          .range([ height, 0]);
        
        var xAxis = d3.axisBottom()
          .scale(x);
          
        var yName = d3.scaleBand()
          .domain(allStates)
          .range([0, height])
          .paddingInner(1)

        var yAxis = d3.axisLeft()
          .scale(yName);
                
        var myColor =  d3.scaleOrdinal()
          .domain(allStates)
          .range(d3.schemeSet3);
        
        var allDensity = [];
        var allMeans = [];
        for (key in allStates){
          var state = allStates[key]
          allMeans.push(d3.mean(state_average_beers[state]));
          var density = kde(epanechnikov(0.3), x.ticks(20), state_average_beers[state])
          allDensity.push({key: state, density: density});
        }
        
        svg.append("g")
          .attr("class", "xAxis")
          .attr("transform", "translate(0," + height + ")")
          .call(xAxis);
                    
        svg.append("g")
          .attr("class", "yAxis")
          .call(yAxis);
        
        // Add areas
        svg.append("g")
          .selectAll("areas")
          .data(allDensity)
          .join("path")
            .attr("transform", function(d){return("translate(0," + (yName(d.key)-height) +")" )})
            .attr("fill", function(d){
              grp = d.key ;
              index = allStates.indexOf(grp)
              value = allMeans[index]
              return myColor(grp)
            })
            .datum(function(d){
              return(d.density)
            })
            .attr("opacity", 0.5)
            .attr("stroke", "#000")
            .attr("stroke-width", 0.1)
            .attr("d",  d3.line()
                .curve(d3.curveBasis)
                .x(function(d) { 
                  return x(d[0]); 
                  
                })
                .y(function(d) { 
                  return y(d[1]); 
                })
            )
      });
      
      function update(bins){
        // Scale the range of the data in the y domain
        y.domain([0, d3.max(bins, function(d) { return d.length;})]);
        
        // append the bar rectangles to the svg element
        var all_recs = svg.select('.hist')
          .selectAll("rect")
          .data(bins, d => d.key);
        
        all_recs.enter().append("rect")
            .attr("class", "bar")
            .attr("fill", (d, i) => myColor(d.color))
            .merge(all_recs)
            .attr("transform", function(d) {
      		    return "translate(" + x(d.x0) + "," + y(d.length) + ")"; 
            })
            .transition()
            .duration(2000)
      		  .attr("width", function(d) { return d3.max([x(d.x1) - x(d.x0) - 1, 0]); })
            .attr("height", function(d) { return height - y(d.length); })
            .style('opacity', 0.8)
        
        all_recs
          .exit()
          .transition()
          .duration(2000)
          .ease(d3.easeLinear)
          .attr("height", 0)
          .remove();
        
        svg.select(".xAxis")
          .transition()
          .duration(2000)
          .ease(d3.easeLinear)
          .call(xAxis);
  
        svg.select(".yAxis")
          .transition()
          .duration(2000)
          .ease(d3.easeLinear)
          .call(yAxis);
      }
    </script>
</html>
