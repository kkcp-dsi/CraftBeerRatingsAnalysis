<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Beer Style</title>
    <script src="https://d3js.org/d3.v7.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src = "https://code.jquery.com/ui/1.10.4/jquery-ui.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <link href = "https://code.jquery.com/ui/1.10.4/themes/ui-lightness/jquery-ui.css" rel = "stylesheet">
  </head>
  
  <body>
    <div class="container-fluid">
      <h2>Background</h2>
      <p class="font-italic">
        Authors: Chao Pang & Krishna Kalluri
      </p>
      <p class="font-italic">
        Class: STAT W5702 002
      </p>
      <p>
        The purpose of this D3 visualization is to better understand the landscape of the craft beer industry. Specifically this visualization is primarily motivated by several questions shown below,
      </p>
        <ul>
          <li>
            What are the popular beer styles?   
          </li>
          <li>
            What beer styles are more popular across different states?   
          </li>
          <li>
            What are the characteristics of each beer style?
          </li>
          <li>
            why are certain beer styles better rated than others? 
          </li>
        </ul>
<p>The D3 visualization combines several plots together including the beer style rating density, beer style popularity over time, beer ibu density, beer abv density, and beer style production by state. Although some of the plots have been shown individual in the results section of our book, we believe looking at the data holistically could give us a better understanding of the data. To avoid overplotting, we've only included the top 20 most popular beer styles in this visualization, which is defined as the number of beers associated with that particular beer style. </p>
    </div>
    <div class="container-fluid">
      <h2>Instructions</h2>
      <p>
        There are two interactive components in this visualization including: 1) a multi-select dropdown box that allows users to add more beer styles to the plots; 2) a beer rating slider for including beers with a specific rating range, the range is cut off at 2.0 on the lower bound because there are almost no beers in that range. In addition under the dropdown box, we included a checkbox a shortcut to include all beer styles in the plots. By default, American IPA, New England IPA, and Sour - Fruited are selected and the rating slider contains the full range of the ratings. At last, we want to make a comment about density plots, where the underlying density function interpolates the missing values therefore the density plots span the ratings that are not selected by the rating slider. 
        
      </p>
    </div>
    </br>
    <div class="container-fluid">
      <div class="row">
        <div class="offset-md-1 col-4">
          <select id="states" style="width:100%"></select>
          <div class="form-check">
            <input class="form-check-input" type="checkbox" value="" id="select_all_states">
            <label class="form-check-label" for="flexCheckDefault">
              Select all beer styles
            </label>
          </div>
        </div>
        <div class="offset-md-1 col-2">
          <p>
          <label for="rating_range">Adjust rating range:</label>
          <input type = "text" id = "rating_range" 
            style = "border:0; font-weight:bold;">
          </p>
        </div>
        <div class="col-2">
          <div id = "rating_range_slider"></div>
        </div>
      </div>
      <div class="row">
        <div class="col-6">
          <div id="state_hist"></div>
        </div>
        <div class="col-6">
          <div id="state_hist_popular"></div>
        </div>
      </div>
      <div class="row">
        <div class="col-6">
          <div id="beer_abv"></div>
        </div>
        <div class="col-6">
          <div id="beer_ibu"></div>
        </div>
      </div>
      <div class="row">
        <div class="col-12">
          <div id="beer_state"></div>
        </div>
      </div>
    </div>
  </body>
  <script>
    // This is what I need to compute kernel density estimation
    function kde(kernel, thresholds, data) {
      return thresholds.map(t => [t, d3.mean(data, d => kernel(t - d))]);
    }
    
    function epanechnikov(bandwidth) {
      return x => Math.abs(x /= bandwidth) <= 1 ? 0.75 * (1 - x * x) / bandwidth : 0;
    }
    
    function create_svg(
      d3_html_element, 
      _margin, 
      _height, 
      _width, 
      _xAxis, 
      _yAxis, 
      _xAxisName){
      // append the svg object to the body of the page
      var _svg = d3_html_element.append("svg")
        .attr("width", _width + _margin.left + _margin.right)
        .attr("height", _height + _margin.top + _margin.bottom)
      .append("g")
        .attr("transform", "translate(" + _margin.left + "," + _margin.top + ")");
        
      _svg.append("g")
      .attr("class", "density")
    
      _svg.append("g")
        .attr("class", "xAxis")
        .attr("transform", "translate(0," + _height + ")")
        .call(_xAxis);
                  
      _svg.append("g")
        .attr("class", "yAxis")
        .call(_yAxis);
        
      // Add X axis label:
      _svg.append("text")
          .attr("text-anchor", "end")
          .attr("x", _width)
          .attr("y", _height + 40)
          .text(_xAxisName);
      return _svg;
    }
    
    function compute_density(states, state_data, ticks)
    {
      var allDensity = [];
      for (i in states){
        var state = states[i]
        var density = kde(epanechnikov(0.3), ticks, state_data[state]);
        allDensity.push({
          key: state,
          median: d3.median(state_data[state]),
          density: density
        });
        
        allDensity = allDensity.sort(function(x, y){
           return d3.descending(x.median, y.median);
        });
      }
      return allDensity;
    }
    
    function update(_svg, allDensity, lineGenerator){
      // Add areas
      var all_density_curves = _svg.select(".density")
        .selectAll("path")
        .data(allDensity, d=>d.key);
      
      all_density_curves.join("path")
        .attr("transform", function(d){return("translate(0," + (yName(d.key) - height) +")")})
        .attr("fill", "#008cf4")
        .attr("data-id", d=>d.key)
        .datum(d=>d.density)
        .transition()
        .duration(500)
        .attr("opacity", 0.8)
        .attr("stroke", "#000")
        .attr("stroke-width", 0.1)
        .attr("d", lineGenerator);
      
      _svg.select('.yAxis').call(yAxis);
      
      _svg.selectAll('path').on("click", function (event){
        var density_key = event.target.getAttribute('data-id');
        console.log(density_key);
      });
    }
    
    function update_hist(_svg, _bins, _xScaleYear, _yScaleYear, _opacity=1.0)
    {
      var all_recs = _svg.select(".density")
        .selectAll("rect")
        .data(_bins, d=>d.key);
      
      var maxBinLength = d3.max(_bins.map(d=>d.length));
      
      var yScaleYearDomainMax = _yScaleYear.domain()[1];
      _yScaleYear.domain([0, yScaleYearDomainMax + 150 * yName.domain().length]);
      
      all_recs.enter().append("rect")
        .attr("class", "bar")
        .merge(all_recs)
        .attr("transform", function(d){
          return("translate(" + _xScaleYear(d.x0) + "," + (yName(d.color) + _yScaleYear(d.length) - height) +")")
        })
        .attr("data-id", d=>d.color)
        .transition()
        .duration(500)
        .ease(d3.easeLinear)
        .attr("fill", "#008cf4")
        .attr("width", d => _xScaleYear(d.x1) - _xScaleYear(d.x0))
        .attr("height", d => height - _yScaleYear(d.length));
      
      all_recs
          .exit()
          .transition()
          .duration(500)
          .ease(d3.easeLinear)
          .attr("height", 0)
          .remove();
      
      _svg.select('.yAxis').call(yAxis);
      
      _yScaleYear.domain([0, yScaleYearDomainMax]);
      
      _svg.selectAll('rect').on("click", function (event){
        var density_key = event.target.getAttribute('data-id');
        console.log(density_key);
      });
    }
    
    function update_state_hist(_bins, _svg, _xScaleState, _yScaleState, _xAxisState, _yAxis, _colorGenerator){
      
      var yScaleYearDomainMax = _yScaleState.domain()[1];
      _yScaleState.domain([0, yScaleYearDomainMax + 1500 * yName.domain().length]);
      
      var all_recs = _svg.select(".density")
        .selectAll("rect")
        .data(_bins, d=>d.key);
      
      all_recs.enter().append("rect")
        .attr("class", "bar")
        .merge(all_recs)
        .attr("transform", function(d){
          return("translate(" + (d.x0 + _xScaleState.bandwidth() / 1.5) + "," + (yName(d.color) + _yScaleState(d.length) - height) +")")
        })
        .attr("data-id", d=>d.color)
        .transition()
        .duration(500)
        .ease(d3.easeLinear)
        .attr("fill", "#008cf4")
        .attr("width", d => _xScaleState.bandwidth() * 0.8)
        .attr("height", d => height - _yScaleState(d.length));
      
      all_recs
          .exit()
          .transition()
          .duration(500)
          .ease(d3.easeLinear)
          .attr("height", 0)
          .remove();
      
      svg_state.select('.yAxis').call(_yAxis);
      svg_state.select('.xAxis').call(_xAxisState);
      
      _yScaleState.domain([0, yScaleYearDomainMax]);
    }

    
    function compute_hist(states, state_data, _histogram)
    {
      var allDensity = [];
      for (i in states){
        var state = states[i]
        var bins = _histogram(state_data[state]);
        bins = d3.map(bins, function(d, j){
          d["key"] = state + j;
          d["color"] = state;
          return d;
        });
        allDensity.push({
          key: state,
          bins: bins
        });
      }
      return allDensity;
    }
    
    function filterBeerByStateData(beer_style_by_state, _selections){
        
      var filteredBeerByStateData = {};
      
      for (i in _selections){
        var style = _selections[i];
        filteredBeerByStateData[style] = {};
        var styleData = beer_style_by_state[style];
        for (state in styleData){
          filteredBeerByStateData[style][state] = styleData[state].filter(d=> (d >= rating_lower_bound && d <= rating_upper_bound))
        }
      }    
      return filteredBeerByStateData;
    }
    
    function filterTopItems(beer_style_data, _selections){
      
      var filterTopItems = {};
      
      for (i in _selections){
        var key = _selections[i];
        var data = beer_style_data[key];
        var filtered_data = {
          'beer_average_rating':[],
          'beer_abv':[],
          'beer_ibu':[],
          'beer_added':[],
          'beer_num_ratings':[]
        };
        for (j in data.beer_average_rating){
          var beerRating = data.beer_average_rating[j];
          if (beerRating >= rating_lower_bound & beerRating <= rating_upper_bound){
            filtered_data.beer_average_rating.push(data.beer_average_rating[j]);
            filtered_data.beer_abv.push(data.beer_abv[j]);
            filtered_data.beer_ibu.push(data.beer_ibu[j]);
            filtered_data.beer_added.push(data.beer_added[j]);
            filtered_data.beer_num_ratings.push(data.beer_num_ratings[j]);
          }
        }
        filterTopItems[key] = filtered_data;
      }
      return filterTopItems;
    }
    
    
    var beer_data_path = "https://raw.githubusercontent.com/kkcp-dsi/CraftBeerRatingsAnalysis/main/data/all_beers_d3.csv";
    var rowConverter = function (d) {
      return {
        state: d.state,
        beer_style: d.beer_style,
        beer_abv: +d.beer_abv,
        beer_ibu: +d.beer_ibu,
        beer_average_rating: +d.beer_average_rating,
        beer_num_ratings: +d.beer_num_ratings,
        beer_added: d.beer_added,
        year: +d.year
        }
    };
    // set the dimensions and margins of the graph
    var margin = {top: 100, right: 40, bottom: 50, left:120},
        width = 400 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;
        
    var stateHistMargin = {top: 100, right: 0, bottom: 50, left:80};
    
     // X axis: scale and draw:
    var xScale = d3.scaleLinear()
      .domain([2.0, 5.0]) 
      .range([0, width]);
    
    var xAxis = d3.axisBottom()
      .scale(xScale);
    
    var yName = d3.scaleBand()
      .range([0, height])
      .paddingInner(1);

    var yAxis = d3.axisLeft()
      .scale(yName);

    var yScale = d3.scaleLinear()
      .domain([0.0, 10.0])
      .range([ height, 0]);
    
    var yScaleYear = d3.scaleLinear()
      .domain([0, 500])
      .range([height, 0]);

    var myColor =  d3.scaleOrdinal()
      .range(d3.schemeSet3);
    
    var lineGenerator = d3.line()
      .curve(d3.curveBasis)
      .x(d=>xScale(d[0]))
      .y(d=>yScale(d[1]));
    
    var xScaleYear = d3.scaleTime().domain(
      [new Date("2010-01-01"), new Date("2022-01-01")]).range([0, width]);
    
    var formatDate = d3.timeFormat("%m/%y");
    var xAxisYear = d3.axisBottom()
      .scale(xScaleYear)
      .tickFormat(formatDate);
    
    var histogram = d3.histogram()
      .value(d=>d)   // I need to give the vector of value
      .domain(xScaleYear.domain())  // then the domain of the graphic
      .thresholds(xScaleYear.ticks(100)); // then the numbers of bins
      
    var histogram_rating = d3.histogram()
      .value(d=>d)   // I need to give the vector of value
      .domain(xScale.domain())  // then the domain of the graphic
      .thresholds(xScale.ticks(100)); // then the numbers of bins
    
    // X axis for ABV
    var xScaleABV = d3.scaleLinear()
      .domain([0.0, 20.0]) 
      .range([0, width]);
    
    var xAxisABV = d3.axisBottom()
      .scale(xScaleABV);
    
    var yScaleABV = d3.scaleLinear()
      .domain([0.0, 4.0])
      .range([ height, 0]);
      
    var histogram_abv = d3.histogram()
      .value(d=>d)
      .domain(xScaleABV.domain())
      .thresholds(xScaleABV.ticks(100));
    
    
    var abvLineGenerator = d3.line()
      .curve(d3.curveBasis)
      .x(d=>xScaleABV(d[0]))
      .y(d=>yScaleABV(d[1]));
    
    // X axis for IBU
    var xScaleIBU = d3.scaleLinear()
      .domain([0.0, 150]) 
      .range([0, width]);
    
    var xAxisIBU = d3.axisBottom()
      .scale(xScaleIBU);
      
    var histogram_ibu = d3.histogram()
      .value(d=>d)
      .domain(xScaleIBU.domain())
      .thresholds(xScaleIBU.ticks(30));
    
    var yScaleIBU = d3.scaleLinear()
      .domain([0.0, 2.0])
      .range([ height, 0]);
    
    var ibuLineGenerator = d3.line()
      .curve(d3.curveBasis)
      .x(d=>xScaleIBU(d[0]))
      .y(d=>yScaleIBU(d[1]));
      
    // X axis for state
    var xScaleState = d3.scaleBand()
      .range([0, width * 3.3]);
    
    var xAxisState = d3.axisBottom()
      .scale(xScaleState);  
      
    var yScaleState = d3.scaleLinear()
      .domain([0.0, 5000])
      .range([ height, 0]);
      
    // append the svg object to the body of the page
    var svg = create_svg(d3.select("#state_hist"), margin, height, width,  xAxis, yAxis, "Beer style average rating");
    
    // append the svg object to the body of the page
    var svg_popularity = create_svg(d3.select("#state_hist_popular"), margin, height, width,  xAxisYear, yAxis, "Beer style popularity");
    
    svg_popularity.select('.xAxis')        
      .selectAll("text")
      .attr("y", 0)
      .attr("x", 9)
      .attr("dy", ".35em")
      .attr("transform", "rotate(" + 45 + ")")
      .style("text-anchor", "start");
    
    var svg_abv = create_svg(d3.select("#beer_abv"), margin, height, width,  xAxisABV, yAxis, "Beer style ABV");
    
    var svg_ibu = create_svg(d3.select("#beer_ibu"), margin, height, width,  xAxisIBU, yAxis, "Beer style IBU");
    
    var svg_state = create_svg(d3.select("#beer_state"), stateHistMargin, height, width * 3.3,  xAxisState, yAxis, "Beer style by state");
  
    var rating_lower_bound = 0.0;
    var rating_upper_bound = 5.0;
      
    $("#rating_range_slider" ).slider({
       range:true,
       min: 200,
       max: 500,
       values: [200, 500],
       slide: function( event, ui ) {
          $("#rating_range" ).val(ui.values[0]/100 + " - " + ui.values[1]/100);
       },
       stop: function( event, ui ) {
          rating_lower_bound = ui.values[0]/100;
          rating_upper_bound = ui.values[1]/100;
          $('#select_all_states').change();
       }
    });
    $( "#rating_range" ).val($( "#rating_range_slider" ).slider("values", 0)/100 +
       " - " + $("#rating_range_slider").slider( "values", 1)/100);
    
    
    d3.csv(beer_data_path, rowConverter).then(function(data){
      var beer_style_data = {};
      var beer_style_by_state = {};
      
      for (var i in data)
      {
        var beer_style = data[i].beer_style;
        var state = data[i].state;
        
        if (!(beer_style in beer_style_data))
        {
          var beer_characteristics = {
            'beer_abv': [],
            'beer_ibu': [],
            'beer_average_rating':[],
            'beer_num_ratings':[],
            'beer_added': [],
            'year': [],
            'state': []
          }
          beer_style_data[beer_style] = beer_characteristics
        }
        
        beer_style_data[beer_style]['beer_abv'].push(data[i].beer_abv);
        beer_style_data[beer_style]['beer_ibu'].push(data[i].beer_ibu);
        beer_style_data[beer_style]['beer_average_rating'].push(data[i].beer_average_rating);
        beer_style_data[beer_style]['beer_num_ratings'].push(data[i].beer_num_ratings);
        beer_style_data[beer_style]['beer_added'].push(new Date(data[i].beer_added));
        beer_style_data[beer_style]['year'].push(data[i].year);
        
        
        if (!(beer_style in beer_style_by_state))
        {
          beer_style_by_state[beer_style] = {};
        }
        
        var translateState = data[i].state;
        if (translateState != undefined)
          translateState = getStateAbbr(data[i].state.replace('_', ' '));
        if (translateState != undefined){
          if (!(translateState in beer_style_by_state[beer_style])){
            beer_style_by_state[beer_style][translateState] = [];
          }
          beer_style_by_state[beer_style][translateState].push(data[i].beer_average_rating);
        }
      }
      
      var items = Object.keys(beer_style_data).map(function(key) {
        return [key, beer_style_data[key]];
      }).sort(
        function(x, y){
          return d3.descending(x[1].beer_average_rating.length, y[1].beer_average_rating.length)
        }
      );
      
      var topItems = items.slice(0, 20);
      var topStyles = topItems.map(d=>d[0]);
      myColor.domain(topStyles);
      
      var allStates = new Set(Object.keys(beer_style_by_state).map(d=>Object.keys(beer_style_by_state[d])).flat());
      
      xScaleState.domain(allStates);
      
      var mySelect = $('#states');
      $.each(topItems, function(key, val) {
        mySelect.append(
            $('<option></option>').val(val[0]).html(val[0])
        );
      });

      $('#select_all_states').change(function() {
          if(this.checked) {
            $('#states').prop('disabled', true);
            
            var filteredData = filterTopItems(beer_style_data, topStyles);
            var filteredBeerStyleByState = filterBeerByStateData(beer_style_by_state, topStyles);
            
            var topItemsRatingData = {};
            var topItemsYearDate = {};
            var topItemsBeerABV = {};
            var topItemsBeerIBU = {};
            var beerStyleStatebins = [];
            
            for (i in topStyles){
              var style = topStyles[i];
              topItemsRatingData[style] = filteredData[style].beer_average_rating;
              topItemsYearDate[style] = filteredData[style].beer_added;
              topItemsBeerABV[style] = filteredData[style].beer_abv.filter(d=>!isNaN(d));
              topItemsBeerIBU[style] = filteredData[style].beer_ibu.filter(d=>!isNaN(d));
              
              for (state in filteredBeerStyleByState[style]){
                beerStyleStatebins.push({
                  'x0' : xScaleState(state) - xScaleState.bandwidth() / 2,
                  'x1' : xScaleState(state) + xScaleState.bandwidth() / 2,
                  'key' : style + state,
                  'color' : style,
                  'length': filteredBeerStyleByState[style][state].length
                });
              }
            }
            
            sortedDensity = compute_density(Object.keys(topItemsRatingData), topItemsRatingData, xScale.ticks(30));
            yName.domain($.map(sortedDensity, d => d.key));
            update(svg, sortedDensity, lineGenerator);
            
            bins = compute_hist(Object.keys(topItemsYearDate), topItemsYearDate, histogram)
              .map(d=>d.bins).flat();
            update_hist(svg_popularity, bins, xScaleYear, yScaleYear);
            
            sortedDensity = compute_density(Object.keys(topItemsBeerABV), topItemsBeerABV, xScaleABV.ticks(30));
            update(svg_abv, sortedDensity, abvLineGenerator);
            
            sortedDensity = compute_density(Object.keys(topItemsBeerIBU), topItemsBeerIBU, xScaleIBU.ticks(30));
            update(svg_ibu, sortedDensity, ibuLineGenerator);
            
            //Beer style by state histogram
            update_state_hist(beerStyleStatebins, svg_state, xScaleState, yScaleState, xAxisState, yAxis, myColor);
            
          }else{
             $('#states').prop('disabled', false);
             $("#states").change();
          }
      });
      
      var stateSelect = $("#states").select2({multiple: true});
      stateSelect.val(["IPA - American", "New England IPA", "Sour - Fruited"]).on("change", function (e) {
        var selections = $(e.currentTarget).val();
        var topItemsRatingData = {};
        var topItemsYearDate = {};
        var topItemsBeerABV = {};
        var topItemsBeerIBU = {};
        var beerStyleStatebins = [];
        
        var filteredData = filterTopItems(beer_style_data, selections);
        var filteredBeerStyleByState = filterBeerByStateData(beer_style_by_state, selections);
        
        for (i in selections){
          
          var style = selections[i];
          topItemsRatingData[style] = filteredData[style].beer_average_rating;
          topItemsYearDate[style] = filteredData[style].beer_added;
          topItemsBeerABV[style] = filteredData[style].beer_abv.filter(d=>!isNaN(d));
          topItemsBeerIBU[style] = filteredData[style].beer_ibu.filter(d=>!isNaN(d));
          
          for (state in filteredBeerStyleByState[style]){
            beerStyleStatebins.push({
              'x0' : xScaleState(state) - xScaleState.bandwidth() / 2,
              'x1' : xScaleState(state) + xScaleState.bandwidth() / 2,
              'key' : style + state,
              'color' : style,
              'length': filteredBeerStyleByState[style][state].length
            });
          }
        }
        
        sortedDensity = compute_density(Object.keys(topItemsRatingData), topItemsRatingData, xScale.ticks(30));
        yName.domain($.map(sortedDensity, d => d.key));
        update(svg, sortedDensity, lineGenerator);
        
        bins = compute_hist(Object.keys(topItemsYearDate), topItemsYearDate, histogram)
          .map(d=>d.bins).flat();
        update_hist(svg_popularity, bins, xScaleYear, yScaleYear);
        
        sortedDensity = compute_density(Object.keys(topItemsBeerABV), topItemsBeerABV, xScaleABV.ticks(30));
        update(svg_abv, sortedDensity, abvLineGenerator);
        
        sortedDensity = compute_density(Object.keys(topItemsBeerIBU), topItemsBeerIBU, xScaleIBU.ticks(30));
        update(svg_ibu, sortedDensity, ibuLineGenerator);
        
        //Beer style by state histogram
        update_state_hist(beerStyleStatebins, svg_state, xScaleState, yScaleState, xAxisState, yAxis, myColor);
      });
      $("#states").change();
    });
    
    var states = {
      'Alabama': 'AL',
      'Alaska': 'AK',
      'American Samoa': 'AS',
      'Arizona': 'AZ',
      'Arkansas': 'AR',
      'California': 'CA',
      'Colorado': 'CO',
      'Connecticut': 'CT',
      'Delaware': 'DE',
      'District Of Columbia': 'DC',
      'Federated States Of Micronesia': 'FM',
      'Florida': 'FL',
      'Georgia': 'GA',
      'Guam': 'GU',
      'Hawaii': 'HI',
      'Idaho': 'ID',
      'Illinois': 'IL',
      'Indiana': 'IN',
      'Iowa': 'IA',
      'Kansas': 'KS',
      'Kentucky': 'KY',
      'Louisiana': 'LA',
      'Maine': 'ME',
      'Marshall Islands': 'MH',
      'Maryland': 'MD',
      'Massachusetts': 'MA',
      'Michigan': 'MI',
      'Minnesota': 'MN',
      'Mississippi': 'MS',
      'Missouri': 'MO',
      'Montana': 'MT',
      'Nebraska': 'NE',
      'Nevada': 'NV',
      'New Hampshire': 'NH',
      'New Jersey': 'NJ',
      'New Mexico': 'NM',
      'New York': 'NY',
      'North Carolina': 'NC',
      'North Dakota': 'ND',
      'Northern Mariana Islands': 'MP',
      'Ohio': 'OH',
      'Oklahoma': 'OK',
      'Oregon': 'OR',
      'Palau': 'PW',
      'Pennsylvania': 'PA',
      'Puerto Rico': 'PR',
      'Rhode Island': 'RI',
      'South Carolina': 'SC',
      'South Dakota': 'SD',
      'Tennessee': 'TN',
      'Texas': 'TX',
      'Utah': 'UT',
      'Vermont': 'VT',
      'Virgin Islands': 'VI',
      'Virginia': 'VA',
      'Washington': 'WA',
      'West Virginia': 'WV',
      'Wisconsin': 'WI',
      'Wyoming': 'WY'
    }
    
    function getStateAbbr(name) {
      return states[name];
    }
    </script>
</html>
